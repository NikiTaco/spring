# Использование паттернов проектирования в Spring-приложении

В данном проекте использованы несколько популярных паттернов проектирования. Вот как они помогают при решении конкретных задач:

## 1. Singleton (Одиночка)
**Где используется:** Класс `SingletonService` с аннотацией `@Service`.

**Проблема:**
- Требуется один и тот же экземпляр сервиса во всём приложении, чтобы избежать избыточного создания объектов и обеспечить консистентное поведение.

**Как помогает:**
- Spring автоматически создаёт и управляет единственным экземпляром класса, аннотированного `@Service` или `@Component`.
- Это уменьшает использование памяти и упрощает управление зависимостями.

**Пример задачи:**
- Логирование, кэширование, или другие задачи, где нужен единый глобальный объект.

---

## 2. Factory Method (Фабричный метод)
**Где используется:** Класс `FactoryConfig` с методом `productService()`.

**Проблема:**
- Необходимо создавать объекты с различными конфигурациями или параметрами без необходимости изменять код, использующий эти объекты.

**Как помогает:**
- Использование метода `@Bean` позволяет создавать объекты с кастомной конфигурацией.
- Код остаётся гибким: вы можете изменять логику создания объектов, не меняя места их использования.

**Пример задачи:**
- Создание объектов с разными настройками (например, подключение к базе данных с разными конфигурациями).

---

## 3. Template Method (Шаблонный метод)
**Где используется:** Абстрактный класс `AbstractProcessingService` и его реализация `ConcreteProcessingService`.

**Проблема:**
- Есть общая последовательность шагов в алгоритме, но детали этих шагов могут различаться в зависимости от конкретного случая.

**Как помогает:**
- Абстрактный класс определяет общий алгоритм, а подклассы переопределяют только специфические шаги.
- Это упрощает добавление новых реализаций, не нарушая общий алгоритм.

**Пример задачи:**
- Обработка платежей, валидация данных или выполнение операций с разными наборами правил.

---

## 4. Observer (Наблюдатель)
**Где используется:** Классы `CustomEvent` (событие), `CustomEventListener` (слушатель), и `EventPublisher`.

**Проблема:**
- Нужно уведомлять несколько частей приложения о каком-либо событии, не создавая прямых зависимостей между ними.

**Как помогает:**
- Использование событий и слушателей в Spring упрощает добавление новых обработчиков событий.
- Код становится более гибким и расширяемым: можно легко добавить новых слушателей, не изменяя основной код.

**Пример задачи:**
- Логирование изменений, отправка уведомлений или выполнение асинхронных операций при наступлении определённых событий.

---

## 5. Dependency Injection (Внедрение зависимостей)
**Где используется:** Класс `MainController`, где зависимости `SingletonService` и `ProductService` передаются через конструктор.

**Проблема:**
- Необходимо управлять зависимостями между объектами, чтобы упростить их замену или тестирование.

**Как помогает:**
- Spring автоматически передаёт зависимости, избавляя вас от необходимости вручную создавать объекты.
- Код становится более модульным и легко тестируемым (зависимости можно заменить на моки).

**Пример задачи:**
- Интеграция сервисов, управление подключениями к базе данных или внедрение логики обработки данных.

---

## Преимущества использования этих паттернов в проекте:
1. **Масштабируемость:** Добавление новых функций или изменение существующих становится проще.
2. **Поддерживаемость:** Чёткое разделение ответственности между классами упрощает понимание и изменение кода.
3. **Повторное использование:** Логика, заложенная в паттерны, может быть использована повторно в разных частях приложения.
4. **Тестируемость:** Слабая связанность между классами упрощает написание тестов.
